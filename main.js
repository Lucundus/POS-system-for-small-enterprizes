const { app: app, BrowserWindow: BrowserWindow, ipcMain: ipcMain, dialog: dialog } = require("electron"), path = require("path"), db = require("./database.js"); function createWindow() { const e = new BrowserWindow({ width: 1200, height: 800, icon: path.join(__dirname, "icon.ico"), webPreferences: { preload: path.join(__dirname, "preload.js"), nodeIntegration: !1, contextIsolation: !0 } }); e.loadFile("index.html"), e.removeMenu() } app.whenReady().then(() => { createWindow(), app.on("activate", () => { 0 === BrowserWindow.getAllWindows().length && createWindow() }) }), app.on("window-all-closed", () => { "darwin" !== process.platform && app.quit() }), ipcMain.handle("get-products", async () => await db.all("SELECT * FROM Products ORDER BY Name ASC")), ipcMain.handle("get-product-by-barcode", async (e, t) => await db.get("SELECT * FROM Products WHERE Barcode = ?", [t])), ipcMain.handle("add-product", async (e, t) => { try { let e = t.barcode; e && "" !== e.trim() || (e = "SYS_NO_BARCODE_" + Date.now() + "_" + Math.floor(1e3 * Math.random())); let a = t.category || "General"; return await db.run("INSERT INTO Products (Barcode, Name, Price, Category) VALUES (?, ?, ?, ?)", [e, t.name, t.price, a]) } catch (e) { return e.message.includes("UNIQUE constraint failed: Products.Barcode") ? { error: "A product with this barcode already exists!" } : { error: e.message } } }), ipcMain.handle("update-product", async (e, t) => { try { let e = t.barcode; e && "" !== e.trim() || (e = "SYS_NO_BARCODE_" + Date.now() + "_" + Math.floor(1e3 * Math.random())); let a = t.category || "General"; return await db.run("UPDATE Products SET Barcode = ?, Name = ?, Price = ?, Category = ? WHERE Id = ?", [e, t.name, t.price, a, t.id]) } catch (e) { return e.message.includes("UNIQUE constraint failed: Products.Barcode") ? { error: "A product with this barcode already exists!" } : { error: e.message } } }), ipcMain.handle("delete-product", async (e, t) => await db.run("DELETE FROM Products WHERE Id = ?", [t])), ipcMain.handle("import-products-excel", async e => { try { const e = await dialog.showOpenDialog({ properties: ["openFile"], filters: [{ name: "Excel Files", extensions: ["xlsx", "xls", "csv"] }] }); if (e.canceled || 0 === e.filePaths.length) return { success: !1, message: "Import cancelled" }; const t = e.filePaths[0], a = require("xlsx"), r = a.readFile(t), s = r.SheetNames[0], n = r.Sheets[s], c = a.utils.sheet_to_json(n); let o = 0, i = 0; for (const e of c) { const t = e.Name || e.Product || e.Item || e.name, a = parseFloat(e.Price || e.price); if (!t || isNaN(a)) continue; let r = e.Barcode || e.barcode || e.ID; r = r ? String(r).trim() : "SYS_NO_BARCODE_" + Date.now() + "_" + Math.floor(1e4 * Math.random()); const s = e.Category || e.category || "General"; try { await db.run("INSERT INTO Products (Barcode, Name, Price, Category) VALUES (?, ?, ?, ?)", [r, t, a, s]), o++ } catch (e) { e.message.includes("UNIQUE constraint failed: Products.Barcode") ? i++ : console.error("Error importing product:", e) } } return { success: !0, count: o, duplicates: i } } catch (e) { return { success: !1, error: e.message } } }), ipcMain.handle("get-customers", async () => await db.all("SELECT * FROM Customers ORDER BY Name ASC")), ipcMain.handle("get-customer", async (e, t) => await db.get("SELECT * FROM Customers WHERE Id = ?", [t])), ipcMain.handle("add-customer", async (e, t) => { try { return await db.run("INSERT INTO Customers (Name, Balance, CreditLimit) VALUES (?, ?, ?)", [t.name, t.balance || 0, t.creditLimit || -3e3]) } catch (e) { return { error: e.message } } }), ipcMain.handle("delete-customer", async (e, t) => await db.run("DELETE FROM Customers WHERE Id = ?", [t])), ipcMain.handle("update-customer", async (e, t) => { try { return await db.run("UPDATE Customers SET Name = ?, Balance = ?, CreditLimit = ? WHERE Id = ?", [t.name, t.balance, t.creditLimit, t.id]) } catch (e) { return { error: e.message } } }), ipcMain.handle("import-customers-excel", async e => { try { const e = await dialog.showOpenDialog({ properties: ["openFile"], filters: [{ name: "Excel Files", extensions: ["xlsx", "xls", "csv"] }] }); if (e.canceled || 0 === e.filePaths.length) return { success: !1, message: "Import cancelled" }; const t = e.filePaths[0], a = require("xlsx"), r = a.readFile(t), s = r.SheetNames[0], n = r.Sheets[s], c = a.utils.sheet_to_json(n); let o = 0; for (const e of c) { const t = e.Name || e["Customer Name"] || e.Customer || e.name; if (!t) continue; const a = parseFloat(e.Balance || e.balance || 0), r = parseFloat(e.CreditLimit || e["Credit Limit"] || e.Limit || -3e3); await db.run("INSERT INTO Customers (Name, Balance, CreditLimit) VALUES (?, ?, ?)", [t, isNaN(a) ? 0 : a, isNaN(r) ? -3e3 : r]), o++ } return { success: !0, count: o } } catch (e) { return { success: !1, error: e.message } } }), ipcMain.handle("export-all-customers", async e => { try { const e = await db.all("SELECT Name, Balance FROM Customers ORDER BY Name ASC"); if (0 === e.length) return { success: !1, error: "No customers found to export." }; const t = await dialog.showSaveDialog({ title: "Export All Customers", defaultPath: `All_Customers_${(new Date).toISOString().split("T")[0]}.xlsx`, filters: [{ name: "Excel Files", extensions: ["xlsx"] }] }); if (t.canceled || !t.filePath) return { success: !1, message: "Export cancelled" }; const a = require("xlsx"), r = a.utils.json_to_sheet(e); r["!cols"] = [{ wch: 30 }, { wch: 15 }]; const s = a.utils.book_new(); return a.utils.book_append_sheet(s, r, "Customers"), a.writeFile(s, t.filePath), { success: !0, filePath: t.filePath } } catch (e) { return { success: !1, error: e.message } } }), ipcMain.handle("process-checkout", async (e, t) => { const { customerId: a, items: r, totalAmount: s } = t; try { if (a) { const e = await db.get("SELECT * FROM Customers WHERE Id = ?", [a]); if (e && e.Balance - s < e.CreditLimit) return { success: !1, error: `Transaction exceeds credit limit. Current Balance: $${e.Balance}, Limit: $${e.CreditLimit}` } } const e = (await db.run("INSERT INTO Transactions (CustomerId, TotalAmount, Type) VALUES (?, ?, ?)", [a || null, s, "SALE"])).id; for (const t of r) await db.run("INSERT INTO TransactionItems (TransactionId, ProductId, Quantity, UnitPrice) VALUES (?, ?, ?, ?)", [e, t.productId, t.quantity, t.price]); return a && await db.run("UPDATE Customers SET Balance = Balance - ? WHERE Id = ?", [s, a]), { success: !0, transactionId: e } } catch (e) { return { success: !1, error: e.message } } }), ipcMain.handle("process-payment", async (e, t) => { const { customerId: a, amount: r } = t; try { return await db.run("BEGIN TRANSACTION"), await db.run("INSERT INTO Transactions (CustomerId, Type, TotalAmount) VALUES (?, ?, ?)", [a, "PAYMENT", r]), await db.run("UPDATE Customers SET Balance = Balance + ? WHERE Id = ?", [r, a]), await db.run("COMMIT"), { success: !0 } } catch (e) { return await db.run("ROLLBACK"), { success: !1, error: e.message } } }), ipcMain.handle("export-customer-history", async (e, t, a) => { try { const e = await db.all("SELECT * FROM Transactions WHERE CustomerId = ? ORDER BY Date ASC", [t]); let r = []; for (const t of e) { let e = ""; "SALE" === t.Type ? e = (await db.all("\n                    SELECT ti.Quantity, p.Name, ti.UnitPrice \n                    FROM TransactionItems ti \n                    JOIN Products p ON ti.ProductId = p.Id \n                    WHERE ti.TransactionId = ?\n                ", [t.Id])).map(e => `${e.Quantity}x ${e.Name}`).join(", ") : "PAYMENT" === t.Type && (e = "Payment Received"), r.push({ Date: new Date(t.Date).toLocaleString(), Type: t.Type, Description: e, TotalAmount: t.TotalAmount }) } if (0 === r.length) return { success: !1, error: "No transaction history found for this customer." }; const s = await dialog.showSaveDialog({ title: "Export Customer History", defaultPath: `Customer_History_${a.replace(/[^a-z0-9]/gi, "_")}.xlsx`, filters: [{ name: "Excel Files", extensions: ["xlsx"] }] }); if (s.canceled || !s.filePath) return { success: !1, message: "Export cancelled" }; const n = require("xlsx"), c = n.utils.json_to_sheet(r); c["!cols"] = [{ wch: 20 }, { wch: 10 }, { wch: 50 }, { wch: 15 }]; const o = n.utils.book_new(); return n.utils.book_append_sheet(o, c, "History"), n.writeFile(o, s.filePath), { success: !0, filePath: s.filePath } } catch (e) { return { success: !1, error: e.message } } }), ipcMain.handle("get-transactions", async () => await db.all("\n        SELECT t.*, c.Name as CustomerName \n        FROM Transactions t \n        LEFT JOIN Customers c ON t.CustomerId = c.Id \n        ORDER BY t.Date DESC LIMIT 100\n    "));
